import { DynamoDB, GSI1Keys, MainTableKeys } from '../integrations/dynamodb';
import { CalibratedQuestionStatus, Dimension, GradingRule } from './calibrated-question';
import { getSessionKey } from './session';

export interface QuestionDocument extends MainTableKeys, GSI1Keys {
  id: string;
  /**
   * The id of the question from the Catalogued Questions
   */
  questionId: string;
  question: string;
  perfectAnswer: string;
  answer?: string;
  /**
   * The prompt evaluation result generated by the GPT for the prompt-engineering questions
   */
  promptResult?: string;
  correctnessGrading?: Grading;
  depthGrading?: Grading;
  dimensionsGrading?: DimensionGrading[];
  gradingRubric?: string;
  /**
   * Default answer that will be provided to the candidate in the UI (optional)
   */
  defaultAnswer?: string;
  /**
   * Optional prompt override settings on question level
   */
  promptSettings?: {
    /**
     * AI model (i.e. "gpt-4", "gpt-3.5-turbo", etc)
     */
    model?: string;
    /**
     * The max amount of attempt for the answer (in case if there are several attempts)
     */
    maxAttempts?: number;
  };
  /**
   * Maximum amount of characters (including whitespaces and any other characters) that are allowed for the candidate
   */
  answerMaxSize?: number;
  /**
   * The amount of attempts to answer the question (used when supporting questions with multiple attempts)
   */
  answerAttempts?: number;
  /**
   * The rubric for the cheating prompt detection
   */
  cheatingRubric?: string;
  /**
   * Result of the cheating check (if present)
   */
  cheatingCheck?: CheatingCheck;
  /**
   * Result of the cheating check using regexes (if present)
   */
  cheatingCheckRegex?: CheatingCheck;
  /**
   * The patterns for the cheating prompt detection
   */
  cheatingPatterns?: string[];
  /**
   * Status of the calibration question at the moment of session initialization
   */
  status?: CalibratedQuestionStatus;
  /**
   * This field stores the conversation for the Skill type: interview
   * Not used in other skill types
   */
  conversation?: ConversationElement[];
  /**
   * Question state. For now, only used in the interview mode and indicates that the question has been already finished
   */
  state?: 'Completed' | null;
  /**
   * Possible question error. For now, only used in the interview mode
   */
  error?: QuestionError;
  /**
   * Optional grading rules for the question
   */
  gradingRules?: GradingRule[];
  /**
   * Grading dimensions (optional for interview)
   */
  dimensions?: Dimension[];
  /**
   * Similarity scores for fraud detection
   */
  similarityScores?: SimilarityScore[];
}

export interface DimensionGrading {
  name: string;
  level: number;
  summary: string;
}

export type QuestionError = 'TokenLimit' | 'ConversationEnded';

export interface Grading {
  summary?: string;
  score?: number;
  reasoning?: string;
}

export interface CheatingCheck {
  summary: string;
  cheated: 'yes' | 'no' | 'unclear';
  checksFailed?: number;
}

export interface ConversationElement {
  /**
   * The contents of the message
   */
  content: string;

  /**
   * The role of the messages author. One of `user` or `assistant`
   */
  role: 'user' | 'assistant';

  /**
   * The reasoning for the message. Only used for extended thinking.
   */
  reasoning?: string;
}

export interface SimilarityScore {
  id: string;
  jaccard: number;
  levenshtein: number;
}

export function getQuestionKey(sessionId: string, questionId: string): MainTableKeys {
  return {
    pk: `SESSION#${sessionId}`,
    sk: `QUESTION#${questionId}`,
  };
}

export class Question {
  static newDocument(
    sessionId: string,
    calibratedQuestionId: string,
    input: Omit<QuestionDocument, 'pk' | 'sk' | 'id'>,
  ): QuestionDocument {
    const mainKey = getQuestionKey(sessionId, calibratedQuestionId);
    return {
      id: calibratedQuestionId,
      answerAttempts: 0,
      gsi1pk: mainKey.sk,
      gsi1sk: mainKey.pk,
      ...mainKey,
      ...input,
    };
  }

  static async getById(
    sessionId: string,
    questionId: string,
    consistentRead?: boolean,
  ): Promise<QuestionDocument | null> {
    return await DynamoDB.getDocument<QuestionDocument>(getQuestionKey(sessionId, questionId), consistentRead);
  }

  static async getAllForSession(sessionId: string): Promise<QuestionDocument[]> {
    const result = await DynamoDB.query({
      KeyConditionExpression: '#pk = :pk AND begins_with(#sk, :sk)',
      ExpressionAttributeNames: {
        '#pk': 'pk',
        '#sk': 'sk',
      },
      ExpressionAttributeValues: {
        ':pk': getSessionKey(sessionId).pk,
        ':sk': 'QUESTION#',
      },
    });

    return (result.Items as QuestionDocument[]) ?? [];
  }

  static async updateAnswerAndAttempt(
    sessionId: string,
    questionId: string,
    answer: string,
    attempt: number,
  ): Promise<void> {
    await DynamoDB.updateDocument({
      Key: getQuestionKey(sessionId, questionId),
      UpdateExpression: 'SET answer = :answer, answerAttempts = :answerAttempts',
      ExpressionAttributeValues: {
        ':answer': answer,
        ':answerAttempts': attempt,
      },
    });
  }

  static async updateConversation(
    sessionId: string,
    questionId: string,
    conversation: ConversationElement[],
  ): Promise<void> {
    await DynamoDB.updateDocument({
      Key: getQuestionKey(sessionId, questionId),
      UpdateExpression: 'SET conversation = :conversation',
      ExpressionAttributeValues: {
        ':conversation': conversation,
      },
    });
  }

  static async updateError(sessionId: string, questionId: string, error: QuestionError): Promise<void> {
    await DynamoDB.updateDocument({
      Key: getQuestionKey(sessionId, questionId),
      UpdateExpression: 'SET #error = :error, #state = :state',
      ExpressionAttributeNames: {
        '#error': 'error',
        '#state': 'state',
      },
      ExpressionAttributeValues: {
        ':error': error,
        ':state': 'Completed',
      },
    });
  }

  static async updatePromptResult(sessionId: string, questionId: string, promptResult: string): Promise<void> {
    await DynamoDB.updateDocument({
      Key: getQuestionKey(sessionId, questionId),
      UpdateExpression: 'SET promptResult = :promptResult',
      ExpressionAttributeValues: {
        ':promptResult': promptResult,
      },
    });
  }

  static getSessionId(question: QuestionDocument): string {
    return question.pk.slice(8);
  }
}
